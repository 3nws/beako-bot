"""
This type stub file was generated by pyright.
"""

import asyncio
import threading
import aiohttp
from typing import Any, Callable, Coroutine, Dict, List, NamedTuple, Optional, TYPE_CHECKING, TypeVar
from .activity import BaseActivity
from .enums import SpeakingState
from typing_extensions import Self
from .client import Client
from .state import ConnectionState
from .voice_client import VoiceClient

"""
The MIT License (MIT)

Copyright (c) 2015-present Rapptz

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
"""
_log = ...
__all__ = ('DiscordWebSocket', 'KeepAliveHandler', 'VoiceKeepAliveHandler', 'DiscordVoiceWebSocket', 'ReconnectWebSocket')
if TYPE_CHECKING:
    ...
class ReconnectWebSocket(Exception):
    """Signals to safely reconnect the websocket."""
    def __init__(self, shard_id: Optional[int], *, resume: bool = ...) -> None:
        ...
    


class WebSocketClosure(Exception):
    """An exception to make up for the fact that aiohttp doesn't signal closure."""
    ...


class EventListener(NamedTuple):
    predicate: Callable[[Dict[str, Any]], bool]
    event: str
    result: Optional[Callable[[Dict[str, Any]], Any]]
    future: asyncio.Future[Any]
    ...


class GatewayRatelimiter:
    def __init__(self, count: int = ..., per: float = ...) -> None:
        ...
    
    def is_ratelimited(self) -> bool:
        ...
    
    def get_delay(self) -> float:
        ...
    
    async def block(self) -> None:
        ...
    


class KeepAliveHandler(threading.Thread):
    def __init__(self, *args: Any, ws: DiscordWebSocket, interval: Optional[float] = ..., shard_id: Optional[int] = ..., **kwargs: Any) -> None:
        ...
    
    def run(self) -> None:
        ...
    
    def get_payload(self) -> Dict[str, Any]:
        ...
    
    def stop(self) -> None:
        ...
    
    def tick(self) -> None:
        ...
    
    def ack(self) -> None:
        ...
    


class VoiceKeepAliveHandler(KeepAliveHandler):
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        ...
    
    def get_payload(self) -> Dict[str, Any]:
        ...
    
    def ack(self) -> None:
        ...
    


class DiscordClientWebSocketResponse(aiohttp.ClientWebSocketResponse):
    async def close(self, *, code: int = ..., message: bytes = ...) -> bool:
        ...
    


DWS = TypeVar('DWS', bound='DiscordWebSocket')
class DiscordWebSocket:
    """Implements a WebSocket for Discord's gateway v10.

    Attributes
    -----------
    DISPATCH
        Receive only. Denotes an event to be sent to Discord, such as READY.
    HEARTBEAT
        When received tells Discord to keep the connection alive.
        When sent asks if your connection is currently alive.
    IDENTIFY
        Send only. Starts a new session.
    PRESENCE
        Send only. Updates your presence.
    VOICE_STATE
        Send only. Starts a new connection to a voice guild.
    VOICE_PING
        Send only. Checks ping time to a voice guild, do not use.
    RESUME
        Send only. Resumes an existing connection.
    RECONNECT
        Receive only. Tells the client to reconnect to a new gateway.
    REQUEST_MEMBERS
        Send only. Asks for the full member list of a guild.
    INVALIDATE_SESSION
        Receive only. Tells the client to optionally invalidate the session
        and IDENTIFY again.
    HELLO
        Receive only. Tells the client the heartbeat interval.
    HEARTBEAT_ACK
        Receive only. Confirms receiving of a heartbeat. Not having it implies
        a connection issue.
    GUILD_SYNC
        Send only. Requests a guild sync.
    gateway
        The gateway we are currently connected to.
    token
        The authentication token for discord.
    """
    if TYPE_CHECKING:
        token: Optional[str]
        _connection: ConnectionState
        _discord_parsers: Dict[str, Callable[..., Any]]
        call_hooks: Callable[..., Any]
        _initial_identify: bool
        shard_id: Optional[int]
        shard_count: Optional[int]
        gateway: str
        _max_heartbeat_timeout: float
        ...
    DISPATCH = ...
    HEARTBEAT = ...
    IDENTIFY = ...
    PRESENCE = ...
    VOICE_STATE = ...
    VOICE_PING = ...
    RESUME = ...
    RECONNECT = ...
    REQUEST_MEMBERS = ...
    INVALIDATE_SESSION = ...
    HELLO = ...
    HEARTBEAT_ACK = ...
    GUILD_SYNC = ...
    def __init__(self, socket: aiohttp.ClientWebSocketResponse, *, loop: asyncio.AbstractEventLoop) -> None:
        ...
    
    @property
    def open(self) -> bool:
        ...
    
    def is_ratelimited(self) -> bool:
        ...
    
    def debug_log_receive(self, data: Dict[str, Any], /) -> None:
        ...
    
    def log_receive(self, _: Dict[str, Any], /) -> None:
        ...
    
    @classmethod
    async def from_client(cls, client: Client, *, initial: bool = ..., gateway: Optional[str] = ..., shard_id: Optional[int] = ..., session: Optional[str] = ..., sequence: Optional[int] = ..., resume: bool = ...) -> Self:
        """Creates a main websocket for Discord from a :class:`Client`.

        This is for internal use only.
        """
        ...
    
    def wait_for(self, event: str, predicate: Callable[[Dict[str, Any]], bool], result: Optional[Callable[[Dict[str, Any]], Any]] = ...) -> asyncio.Future[Any]:
        """Waits for a DISPATCH'd event that meets the predicate.

        Parameters
        -----------
        event: :class:`str`
            The event name in all upper case to wait for.
        predicate
            A function that takes a data parameter to check for event
            properties. The data parameter is the 'd' key in the JSON message.
        result
            A function that takes the same data parameter and executes to send
            the result to the future. If ``None``, returns the data.

        Returns
        --------
        asyncio.Future
            A future to wait for.
        """
        ...
    
    async def identify(self) -> None:
        """Sends the IDENTIFY packet."""
        ...
    
    async def resume(self) -> None:
        """Sends the RESUME packet."""
        ...
    
    async def received_message(self, msg: Any, /) -> None:
        ...
    
    @property
    def latency(self) -> float:
        """:class:`float`: Measures latency between a HEARTBEAT and a HEARTBEAT_ACK in seconds."""
        ...
    
    async def poll_event(self) -> None:
        """Polls for a DISPATCH event and handles the general gateway loop.

        Raises
        ------
        ConnectionClosed
            The websocket connection was terminated for unhandled reasons.
        """
        ...
    
    async def debug_send(self, data: str, /) -> None:
        ...
    
    async def send(self, data: str, /) -> None:
        ...
    
    async def send_as_json(self, data: Any) -> None:
        ...
    
    async def send_heartbeat(self, data: Any) -> None:
        ...
    
    async def change_presence(self, *, activity: Optional[BaseActivity] = ..., status: Optional[str] = ..., since: float = ...) -> None:
        ...
    
    async def request_chunks(self, guild_id: int, query: Optional[str] = ..., *, limit: int, user_ids: Optional[List[int]] = ..., presences: bool = ..., nonce: Optional[str] = ...) -> None:
        ...
    
    async def voice_state(self, guild_id: int, channel_id: Optional[int], self_mute: bool = ..., self_deaf: bool = ...) -> None:
        ...
    
    async def close(self, code: int = ...) -> None:
        ...
    


DVWS = TypeVar('DVWS', bound='DiscordVoiceWebSocket')
class DiscordVoiceWebSocket:
    """Implements the websocket protocol for handling voice connections.

    Attributes
    -----------
    IDENTIFY
        Send only. Starts a new voice session.
    SELECT_PROTOCOL
        Send only. Tells discord what encryption mode and how to connect for voice.
    READY
        Receive only. Tells the websocket that the initial connection has completed.
    HEARTBEAT
        Send only. Keeps your websocket connection alive.
    SESSION_DESCRIPTION
        Receive only. Gives you the secret key required for voice.
    SPEAKING
        Send only. Notifies the client if you are currently speaking.
    HEARTBEAT_ACK
        Receive only. Tells you your heartbeat has been acknowledged.
    RESUME
        Sent only. Tells the client to resume its session.
    HELLO
        Receive only. Tells you that your websocket connection was acknowledged.
    RESUMED
        Sent only. Tells you that your RESUME request has succeeded.
    CLIENT_CONNECT
        Indicates a user has connected to voice.
    CLIENT_DISCONNECT
        Receive only.  Indicates a user has disconnected from voice.
    """
    if TYPE_CHECKING:
        thread_id: int
        _connection: VoiceClient
        gateway: str
        _max_heartbeat_timeout: float
        ...
    IDENTIFY = ...
    SELECT_PROTOCOL = ...
    READY = ...
    HEARTBEAT = ...
    SESSION_DESCRIPTION = ...
    SPEAKING = ...
    HEARTBEAT_ACK = ...
    RESUME = ...
    HELLO = ...
    RESUMED = ...
    CLIENT_CONNECT = ...
    CLIENT_DISCONNECT = ...
    def __init__(self, socket: aiohttp.ClientWebSocketResponse, loop: asyncio.AbstractEventLoop, *, hook: Optional[Callable[..., Coroutine[Any, Any, Any]]] = ...) -> None:
        ...
    
    async def send_as_json(self, data: Any) -> None:
        ...
    
    send_heartbeat = ...
    async def resume(self) -> None:
        ...
    
    async def identify(self) -> None:
        ...
    
    @classmethod
    async def from_client(cls, client: VoiceClient, *, resume: bool = ..., hook: Optional[Callable[..., Coroutine[Any, Any, Any]]] = ...) -> Self:
        """Creates a voice websocket for the :class:`VoiceClient`."""
        ...
    
    async def select_protocol(self, ip: str, port: int, mode: int) -> None:
        ...
    
    async def client_connect(self) -> None:
        ...
    
    async def speak(self, state: SpeakingState = ...) -> None:
        ...
    
    async def received_message(self, msg: Dict[str, Any]) -> None:
        ...
    
    async def initial_connection(self, data: Dict[str, Any]) -> None:
        ...
    
    @property
    def latency(self) -> float:
        """:class:`float`: Latency between a HEARTBEAT and its HEARTBEAT_ACK in seconds."""
        ...
    
    @property
    def average_latency(self) -> float:
        """:class:`float`: Average of last 20 HEARTBEAT latencies."""
        ...
    
    async def load_secret_key(self, data: Dict[str, Any]) -> None:
        ...
    
    async def poll_event(self) -> None:
        ...
    
    async def close(self, code: int = ...) -> None:
        ...
    


