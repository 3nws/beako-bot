"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Coroutine, Generator, Generic, List, Literal, Optional, Sequence, TYPE_CHECKING, TypeVar, Union, overload
from .models import AppCommand
from .commands import Command, CommandCallback, ContextMenu, ContextMenuCallback, Group, P, T
from .errors import AppCommandError
from ..enums import AppCommandType
from ..interactions import Interaction
from ..abc import Snowflake

"""
The MIT License (MIT)

Copyright (c) 2015-present Rapptz

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
"""
if TYPE_CHECKING:
    ErrorFunc = Callable[[Interaction, AppCommandError], Coroutine[Any, Any, Any],]
__all__ = ('CommandTree', )
ClientT = TypeVar('ClientT', bound='Client')
class CommandTree(Generic[ClientT]):
    """Represents a container that holds application command information.

    Parameters
    -----------
    client: :class:`~discord.Client`
        The client instance to get application command information from.
    fallback_to_global: :class:`bool`
        If a guild-specific command is not found when invoked, then try falling back into
        a global command in the tree. For example, if the tree locally has a ``/ping`` command
        under the global namespace but the guild has a guild-specific ``/ping``, instead of failing
        to find the guild-specific ``/ping`` command it will fall back to the global ``/ping`` command.
        This has the potential to raise more :exc:`~discord.app_commands.CommandSignatureMismatch` errors
        than usual. Defaults to ``True``.
    """
    def __init__(self, client: ClientT, *, fallback_to_global: bool = ...) -> None:
        ...
    
    async def fetch_commands(self, *, guild: Optional[Snowflake] = ...) -> List[AppCommand]:
        """|coro|

        Fetches the application's current commands.

        If no guild is passed then global commands are fetched, otherwise
        the guild's commands are fetched instead.

        .. note::

            This includes context menu commands.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to fetch the commands from. If not passed then global commands
            are fetched instead.

        Raises
        -------
        HTTPException
            Fetching the commands failed.
        MissingApplicationID
            The application ID could not be found.

        Returns
        --------
        List[:class:`~discord.app_commands.AppCommand`]
            The application's commands.
        """
        ...
    
    def copy_global_to(self, *, guild: Snowflake) -> None:
        """Copies all global commands to the specified guild.

        This method is mainly available for development purposes, as it allows you
        to copy your global commands over to a testing guild easily and prevent waiting
        an hour for the propagation.

        Note that this method will *override* pre-existing guild commands that would conflict.

        Parameters
        -----------
        guild: :class:`~discord.abc.Snowflake`
            The guild to copy the commands to.

        Raises
        --------
        CommandLimitReached
            The maximum number of commands was reached for that guild.
            This is currently 100 for slash commands and 5 for context menu commands.
        """
        ...
    
    def add_command(self, command: Union[Command[Any, ..., Any], ContextMenu, Group], /, *, guild: Optional[Snowflake] = ..., guilds: Sequence[Snowflake] = ..., override: bool = ...) -> None:
        """Adds an application command to the tree.

        This only adds the command locally -- in order to sync the commands
        and enable them in the client, :meth:`sync` must be called.

        The root parent of the command is added regardless of the type passed.

        Parameters
        -----------
        command: Union[:class:`Command`, :class:`Group`]
            The application command or group to add.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to add the command to. If not given or ``None`` then it
            becomes a global command instead.
        guilds: List[:class:`~discord.abc.Snowflake`]
            The list of guilds to add the command to. This cannot be mixed
            with the ``guild`` parameter. If no guilds are given at all
            then it becomes a global command instead.
        override: :class:`bool`
            Whether to override a command with the same name. If ``False``
            an exception is raised. Default is ``False``.

        Raises
        --------
        ~discord.app_commands.CommandAlreadyRegistered
            The command was already registered and no override was specified.
        TypeError
            The application command passed is not a valid application command.
            Or, ``guild`` and ``guilds`` were both given.
        CommandLimitReached
            The maximum number of commands was reached globally or for that guild.
            This is currently 100 for slash commands and 5 for context menu commands.
        """
        ...
    
    @overload
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> Optional[ContextMenu]:
        ...
    
    @overload
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input] = ...) -> Optional[Union[Command[Any, ..., Any], Group]]:
        ...
    
    @overload
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        ...
    
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType = ...) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        """Removes an application command from the tree.

        This only removes the command locally -- in order to sync the commands
        and remove them in the client, :meth:`sync` must be called.

        Parameters
        -----------
        command: :class:`str`
            The name of the root command to remove.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to remove the command from. If not given or ``None`` then it
            removes a global command instead.
        type: :class:`~discord.AppCommandType`
            The type of command to remove. Defaults to :attr:`~discord.AppCommandType.chat_input`,
            i.e. slash commands.

        Returns
        ---------
        Optional[Union[:class:`Command`, :class:`ContextMenu`, :class:`Group`]]
            The application command that got removed.
            If nothing was removed then ``None`` is returned instead.
        """
        ...
    
    def clear_commands(self, *, guild: Optional[Snowflake], type: Optional[AppCommandType] = ...) -> None:
        """Clears all application commands from the tree.

        This only removes the commands locally -- in order to sync the commands
        and remove them in the client, :meth:`sync` must be called.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to remove the commands from. If ``None`` then it
            removes all global commands instead.
        type: :class:`~discord.AppCommandType`
            The type of command to clear. If not given or ``None`` then it removes all commands
            regardless of the type.
        """
        ...
    
    @overload
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> Optional[ContextMenu]:
        ...
    
    @overload
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input] = ...) -> Optional[Union[Command[Any, ..., Any], Group]]:
        ...
    
    @overload
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        ...
    
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType = ...) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        """Gets a application command from the tree.

        Parameters
        -----------
        command: :class:`str`
            The name of the root command to get.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to get the command from. If not given or ``None`` then it
            gets a global command instead.
        type: :class:`~discord.AppCommandType`
            The type of command to get. Defaults to :attr:`~discord.AppCommandType.chat_input`,
            i.e. slash commands.

        Returns
        ---------
        Optional[Union[:class:`Command`, :class:`ContextMenu`, :class:`Group`]]
            The application command that was found.
            If nothing was found then ``None`` is returned instead.
        """
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> List[ContextMenu]:
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input]) -> List[Union[Command[Any, ..., Any], Group]]:
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Union[List[Union[Command[Any, ..., Any], Group]], List[ContextMenu]]:
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Optional[AppCommandType] = ...) -> List[Union[Command[Any, ..., Any], Group, ContextMenu]]:
        ...
    
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Optional[AppCommandType] = ...) -> Union[List[ContextMenu], List[Union[Command[Any, ..., Any], Group]], List[Union[Command[Any, ..., Any], Group, ContextMenu]],]:
        """Gets all application commands from the tree.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to get the commands from, not including global commands.
            If not given or ``None`` then only global commands are returned.
        type: Optional[:class:`~discord.AppCommandType`]
            The type of commands to get. When not given or ``None``, then all
            command types are returned.

        Returns
        ---------
        List[Union[:class:`ContextMenu`, :class:`Command`, :class:`Group`]]
            The application commands from the tree.
        """
        ...
    
    @overload
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> Generator[ContextMenu, None, None]:
        ...
    
    @overload
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input] = ...) -> Generator[Union[Command[Any, ..., Any], Group], None, None]:
        ...
    
    @overload
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Union[Generator[Union[Command[Any, ..., Any], Group], None, None], Generator[ContextMenu, None, None]]:
        ...
    
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: AppCommandType = ...) -> Union[Generator[Union[Command[Any, ..., Any], Group], None, None], Generator[ContextMenu, None, None]]:
        """An iterator that recursively walks through all application commands and child commands from the tree.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to iterate the commands from, not including global commands.
            If not given or ``None`` then only global commands are iterated.
        type: :class:`~discord.AppCommandType`
            The type of commands to iterate over. Defaults to :attr:`~discord.AppCommandType.chat_input`,
            i.e. slash commands.

        Yields
        ---------
        Union[:class:`ContextMenu`, :class:`Command`, :class:`Group`]
            The application commands from the tree.
        """
        ...
    
    async def on_error(self, interaction: Interaction, error: AppCommandError) -> None:
        """|coro|

        A callback that is called when any command raises an :exc:`AppCommandError`.

        The default implementation prints the traceback to stderr if the command does
        not have any error handlers attached to it.

        To get the command that failed, :attr:`discord.Interaction.command` should
        be used.

        Parameters
        -----------
        interaction: :class:`~discord.Interaction`
            The interaction that is being handled.
        error: :exc:`AppCommandError`
            The exception that was raised.
        """
        ...
    
    def error(self, coro: ErrorFunc) -> ErrorFunc:
        """A decorator that registers a coroutine as a local error handler.

        This must match the signature of the :meth:`on_error` callback.

        The error passed will be derived from :exc:`AppCommandError`.

        Parameters
        -----------
        coro: :ref:`coroutine <coroutine>`
            The coroutine to register as the local error handler.

        Raises
        -------
        TypeError
            The coroutine passed is not actually a coroutine or does
            not match the signature.
        """
        ...
    
    def command(self, *, name: str = ..., description: str = ..., nsfw: bool = ..., guild: Optional[Snowflake] = ..., guilds: Sequence[Snowflake] = ...) -> Callable[[CommandCallback[Group, P, T]], Command[Group, P, T]]:
        """Creates an application command directly under this tree.

        Parameters
        ------------
        name: :class:`str`
            The name of the application command. If not given, it defaults to a lower-case
            version of the callback name.
        description: :class:`str`
            The description of the application command. This shows up in the UI to describe
            the application command. If not given, it defaults to the first line of the docstring
            of the callback shortened to 100 characters.
        nsfw: :class:`bool`
            Whether the command is NSFW and should only work in NSFW channels. Defaults to ``False``.

            Due to a Discord limitation, this does not work on subcommands.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to add the command to. If not given or ``None`` then it
            becomes a global command instead.
        guilds: List[:class:`~discord.abc.Snowflake`]
            The list of guilds to add the command to. This cannot be mixed
            with the ``guild`` parameter. If no guilds are given at all
            then it becomes a global command instead.
        """
        ...
    
    def context_menu(self, *, name: str = ..., nsfw: bool = ..., guild: Optional[Snowflake] = ..., guilds: Sequence[Snowflake] = ...) -> Callable[[ContextMenuCallback], ContextMenu]:
        """Creates a application command context menu from a regular function directly under this tree.

        This function must have a signature of :class:`~discord.Interaction` as its first parameter
        and taking either a :class:`~discord.Member`, :class:`~discord.User`, or :class:`~discord.Message`,
        or a :obj:`typing.Union` of ``Member`` and ``User`` as its second parameter.

        Examples
        ---------

        .. code-block:: python3

            @app_commands.context_menu()
            async def react(interaction: discord.Interaction, message: discord.Message):
                await interaction.response.send_message('Very cool message!', ephemeral=True)

            @app_commands.context_menu()
            async def ban(interaction: discord.Interaction, user: discord.Member):
                await interaction.response.send_message(f'Should I actually ban {user}...', ephemeral=True)

        Parameters
        ------------
        name: :class:`str`
            The name of the context menu command. If not given, it defaults to a title-case
            version of the callback name. Note that unlike regular slash commands this can
            have spaces and upper case characters in the name.
        nsfw: :class:`bool`
            Whether the command is NSFW and should only work in NSFW channels. Defaults to ``False``.

            Due to a Discord limitation, this does not work on subcommands.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to add the command to. If not given or ``None`` then it
            becomes a global command instead.
        guilds: List[:class:`~discord.abc.Snowflake`]
            The list of guilds to add the command to. This cannot be mixed
            with the ``guild`` parameter. If no guilds are given at all
            then it becomes a global command instead.
        """
        ...
    
    async def sync(self, *, guild: Optional[Snowflake] = ...) -> List[AppCommand]:
        """|coro|

        Syncs the application commands to Discord.

        This must be called for the application commands to show up.

        Global commands take up to 1-hour to propagate but guild
        commands propagate instantly.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to sync the commands to. If ``None`` then it
            syncs all global commands instead.

        Raises
        -------
        HTTPException
            Syncing the commands failed.
        Forbidden
            The client does not have the ``applications.commands`` scope in the guild.
        MissingApplicationID
            The client does not have an application ID.

        Returns
        --------
        List[:class:`AppCommand`]
            The application's commands that got synced.
        """
        ...
    
    async def interaction_check(self, interaction: Interaction, /) -> bool:
        """|coro|

        A global check to determine if an :class:`~discord.Interaction` should
        be processed by the tree.

        The default implementation returns True (all interactions are processed),
        but can be overridden if custom behaviour is desired.
        """
        ...
    
    async def call(self, interaction: Interaction) -> None:
        """|coro|

        Given an :class:`~discord.Interaction`, calls the matching
        application command that's being invoked.

        This is usually called automatically by the library.

        Parameters
        -----------
        interaction: :class:`~discord.Interaction`
            The interaction to dispatch from.

        Raises
        --------
        CommandNotFound
            The application command referred to could not be found.
        CommandSignatureMismatch
            The interaction data referred to a parameter that was not found in the
            application command definition.
        AppCommandError
            An error occurred while calling the command.
        """
        ...
    


